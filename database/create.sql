
-- 
-- Tabla: Tipos de Cursos
--

CREATE TABLE Tipos_Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL,
    DESCRIPCION                 VARCHAR2(4000),

 -- CONSTRAINS
    CONSTRAINT PK_Tipos_Cursos PRIMARY KEY (ID),
    CONSTRAINT UQ_Tipos_Cursos_Codigo UNIQUE (CODIGO)
);

-- 
-- Tabla: Cursos
--

CREATE TABLE Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL,
    DURACION                    NUMBER,
    TIPO                        NUMBER,
    PRECIO_PARA_EMPRESAS        NUMBER,
    PRECIO_PARA_PARTICULARES    NUMBER,
    DESCRIPCION                 VARCHAR2(4000),

 -- CONSTRAINS
    -- Primary Key. Siempre tenemos uno
    CONSTRAINT PK_Cursos PRIMARY                KEY (ID),
    -- Unique: Es nuestro ID PUBLICO
    CONSTRAINT UQ_Cursos_Codigo                 UNIQUE (CODIGO),
                                                -- Este campo, por tener ser una clave única en automático tiene un índice asociado
                                                -- Búsquedas del tipo WHERE CODIGO = 'valor' serán muy rápidas
                                                -- Búsquedas del tipo WHERE CODIGO LIKE 'valor%' serán muy rápidas
    -- Foreign Key hacia Tipos_Cursos
    CONSTRAINT FK_Cursos_Tipo FOREIGN           KEY (TIPO) REFERENCES Tipos_Cursos(ID),
    -- Restricciones al valor de los campos
                                                -- AQUI PONEMOS UNA EXPRESION QUE DEVUELVA UN BOOLEANO
                                                -- Si devuelve TRUE, se acepta el valor
                                                -- Si devuelve FALSE, se rechaza el valor
    CONSTRAINT CHK_Cursos_Duracion              CHECK (DURACION IS NULL OR DURACION > 0),
    CONSTRAINT CHK_Cursos_Precio_Empresas       CHECK (PRECIO_PARA_EMPRESAS IS NULL OR PRECIO_PARA_EMPRESAS >= 0),
    CONSTRAINT CHK_Cursos_Precio_Particulares   CHECK (PRECIO_PARA_PARTICULARES IS NULL OR PRECIO_PARA_PARTICULARES >= 0)
    CONSTRAINT CHK_Cursos_Codigo_Mayusculas     CHECK (CODIGO = UPPER(CODIGO) AND REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
);


-- Notas respecto al campo CODIGO:
-- - Será muy recomendable implementar un AUTOCOMPLETAR en los formularios de búsqueda: ORA-     ora-      Ora-
-- - Podría ser que el usuario escriba minúsculas o mayúsculas de forma indistinta al buscar <- Quiero dar esa opción?
-- - Lo que nos estamos preguntando es: Quiero que el valor de ese campo sea case-sensitive o case-insensitive?
-- - Y en un campo como este, lo guay es que sea case-insensitive
-- - Esa funcionalidad la podríamos implementar en una query : WHERE UPPER(CODIGO) = UPPER('valor_del_usuario')
--                                                             WHERE UPPER(CODIGO) LIKE UPPER('valor_del_usuario') || '%'
--                                                             WHERE UPPER(CODIGO) LIKE '%' || UPPER('valor_del_usuario') || '%'
-- Pregunta?  Me funciona el índice que he creado en esos casos?
-- Respuesta: NO, ya que lo que tengo indexado es el valor del CODIGO... y en la query se usa el UPPER(CODIGO).
--            Y ese valor no está indexado!
-- Esto implica que hay que transformar bajo demanda, en cada query, todos los valores del campo CODIGO a mayúsculas
-- para poder comparar con el valor que ha dado el usuario. EL INDICE SE VUELVE INUTIL!
-- Opciones:
-- 1. Transformar en automático el valor del campo CODIGO a mayúsculas en el momento de hacer el INSERT o el UPDATE
--    Eso lo permite SQL? NO
--    Con un trigger y PL/SQL SÍ
-- 2. Forzar que el campo solo pueda recibir valores en mayúsculas. Limitación al rango de valores aceptables
--    Eso lo permite SQL? SÍ, con un CONSTRAINT CHECK
-- 3. Generar un índice adicional basado en la función UPPER(CODIGO). Índice funcional
--    Eso lo permite SQL? SÍ
--    CREATE INDEX IX_Cursos_Codigo_Upper ON Cursos(UPPER(CODIGO));
--    En este caso, tendríamos 2 índices. Más espacio y más tiempo en los INSERTs/UPDATEs.
--    Y Además, lo que me gustaría es de alguna forma NORMALIZAR el valor del campo CODIGO a mayúsculas.
--    Esto no exige que el campo se almacene en mayúsculas, pero sí que el valor indexado lo esté.
--    En otros escenarios, esto podría ser una solución interesante. En este NO.

-- Entre opción 1 y opción 2, nos quedamos con las 2.
-- La opción 2, es la que asegura que el valor del campo CODIGO siempre estará en mayúsculas.
-- La opción 1, es la que nos permite dar al usuario la flexibilidad de escribir minúsculas o mayúsculas al dar de alta el campo.

-- Implementando eso (o incluso si implementamos la opción 3), las búsquedas que usarán índice serían:
-- WHERE CODIGO = UPPER('VALOR_EN_MAYUSCULAS')
-- WHERE CODIGO LIKE UPPER('VALOR_EN_MAYUSCULAS') || '%'
-- ESTA NO FUNCIONA : WHERE CODIGO LIKE '%' || UPPER('VALOR_EN_MAYUSCULAS') 
--                    La búsqueda sin funcionaría, pero no usaría índice
-- El % al principio en los LIKES impide usar índice. Estas queries deberían estar proscritas en un entorno con grandes volúmenes de datos.
-- A no ser que tenga 200 datos en la tabla, claro.
-- Si quiero búsquedas de ese estilo, o búsquedas que no discrimen por acentos, o que automáticamente ignoren mayúsculas/minúsculas, la solución es otra:
-- - Índices invertidos full text: Oracle Text (eso viene con la propia licencia de Oracle Database), aunque he de activarlo explícitamente y configurarlo


-- Trigger para asegurar que el campo CODIGO siempre se almacena en mayúsculas
CREATE OR REPLACE TRIGGER TRG_Cursos_Codigo_Mayusculas
BEFORE INSERT OR UPDATE ON Cursos
FOR EACH ROW
BEGIN
    -- Solo transformamos el valor si no es NULL
    -- De esta forma evitamos que el trigger falle al intentar transformar un NULL
    -- Si es nulo, lo dejamos como está, es decir NULL
    -- Y ya la restricción NOT NULL definida en la tabla se encargará de rechazarlo si es necesario dando un mensaje adecuado al usuario

    -- En el caso de un UPDATE, si el valor no cambia, el valor :NEW.CODIGO se queda como está, no lo tocamos... y sigue funcionando bien.
    IF :NEW.CODIGO IS NOT NULL THEN 
        :NEW.CODIGO := UPPER(:NEW.CODIGO);
    END IF;
END;
/
-- Nota: El trigger se define con una barra (/) al final para indicar a SQL*Plus que ejecute el bloque PL/SQL.


-- Tabla Profesores:
-- ID, Nombre, Apellidos, DNI


CREATE TABLE Profesores (
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE                      VARCHAR2(50)    NOT NULL,
    APELLIDOS                   VARCHAR2(150)   NOT NULL,
    DNI                         VARCHAR2(9)     NOT NULL,

 -- CONSTRAINS
    -- Primary Key. Siempre tenemos uno
    CONSTRAINT PK_Profesores PRIMARY             KEY (ID),
    -- Unique: Es nuestro ID PUBLICO
    CONSTRAINT UQ_Profesores_DNI                 UNIQUE (DNI)
    -- Restricciones al DNI aplicadas mediante un TRIGGER
);


-- Cómo es un DNI? 1-8 dígitos + letra mayúscula. Puntos y guiones opcionales
-- Para guardarlo podría usar un VARCHAR2(9). Cuánto ocuparía? 1byte por carácter = 9 bytes
-- Y si guardo el número como NUMBER(8) y la letra como CHAR(1)?  Número: 1 byte por cada 2 dígitos + 1 byte para la letra = 5 bytes
-- Cuantas personas tengo? 10.000.. Me la pela. 10.000.000... me lo planteo!

-- Meteremos un trigger a esa tabla para?
-- - Validar que lo que llega es correcto (formato + letra correcta)
-- - Normalizarlo (quitar puntos y guiones, poner letra en mayúsculas)


CREATE OR REPLACE PROCEDURE validar_dni (
    dni IN VARCHAR2,
    valido OUT BOOLEAN,
    numero OUT NUMBER,
    letra OUT CHAR
)
IS
    -- Declaración de variables locales
    letras_validas      CONSTANT    VARCHAR2(23) := 'TRWAGMYFPDXBNJZSQVHLCKE';
    patron_dni          CONSTANT    VARCHAR2(100) := '^(([0-9]{1,8})|([0-9]{1,2}([.][0-9]{3}){2})|([0-9]{1,3}[.][0-9]{3}))[ -]?[A-Za-z]$';
    patron_no_numerico  CONSTANT    VARCHAR2(100) := '[^0-9]';
    letra_correcta                  CHAR(1);
BEGIN
    valido := FALSE; -- Valor por defecto
    -- Cuerpo de la función
    IF dni IS NULL THEN
        RETURN ;
    END IF;
    -- Validar si tiene pinta de DNI (Expresión regular)
    -- Si no tiene pinta, devolver FALSE
    IF NOT REGEXP_LIKE(dni, patron_dni) THEN
        RETURN ;
    END IF;
    -- Si si tiene pinta de dni: Debo verificar la letra
    -- Extraer el número, quitando puntos y guiones, espacios y cogiendo solo los dígitos
    -- Reemplazamos todo lo que haya en el texto que no sean dígitos por nada
    numero := TO_NUMBER(REGEXP_REPLACE(dni, patron_no_numerico, '')); -- Todo lo que no sean números me lo como!
    -- Extraer la letra (último carácter)
    letra := UPPER(SUBSTR(dni, -1, 1)); -- Tomo un caracter(1) desde el último (-1)... y además transformo a mayúsculas
    -- Calcular la letra correcta que debería traer ese dni, en base al número
    letra_correcta := SUBSTR(letras_validas, MOD(numero, 23) + 1, 1); -- +1 porque los índices en SUBSTR empiezan en 1
    -- Verificar que es la que se ha suminitrado
    valido := (letra = letra_correcta);
END;
/

CREATE OR REPLACE TRIGGER TRG_Profesores_DNI_Validar_Normalizar
BEFORE INSERT OR UPDATE ON Profesores
FOR EACH ROW
DECLARE
    dni_valido      BOOLEAN;
    dni_numero      NUMBER(8);
    dni_letra       CHAR(1);
BEGIN
    -- Si el DNI Es null, no hacemos nada, y que el propio NOT NULL de la tabla se encargue de rechazarlo
    IF :NEW.DNI IS NULL THEN
        RETURN;
    END IF;
    -- Validar el formato del DNI
    validar_dni(:NEW.DNI, dni_valido, dni_numero, dni_letra);
    IF NOT dni_valido THEN
        RAISE_APPLICATION_ERROR(-20001, 'DNI inválido: ' || :NEW.DNI); -- Este mensaje le saldrá al usuario si el DNI no es válido
    ELSE
        -- Si es válido, normalizar el valor del DNI
        :NEW.DNI := TO_CHAR(dni_numero) || dni_letra; -- Número sin ceros a la izquierda + letra en mayúsculas, sin puntos ni separadores
    END IF;
END;
/

-- Esto estaría acabado! al menos lo referente a la tabla profesores.ALTER
-- Pero... ya que tengo ese procedimiento, me podría interesar generar un par de funciones adicionales, que los usuarios puedan usar en sus queries SQL.

-- funcion: es_dni_valido(dni IN VARCHAR2) RETURN NUMBER 
-- OJO. En SQL no puedo usar una función que devuelva BOOLEAN.
-- Como se comporta ante un nulo? Devuelva 0;
-- En SQL los booleanos no existen. Así que devuelvo un NUMBER: 1 = TRUE, 0 = FALSE

CREATE OR REPLACE FUNCTION es_dni_valido (
    dni IN VARCHAR2
) RETURN NUMBER
IS
    dni_valido      BOOLEAN;
    dni_numero      NUMBER(8);
    dni_letra       CHAR(1);
BEGIN
    validar_dni(dni, dni_valido, dni_numero, dni_letra);
    --IF dni_valido THEN
    --    RETURN 1;
    --ELSE
    --    RETURN 0;
    --END IF;
    RETURN CASE 
               WHEN dni_valido THEN 1
               ELSE 0
           END;
END;
/

-- funcion: normalizar_dni(dni IN VARCHAR2) RETURN VARCHAR2
-- Si el dni no es válido, devuelve NULL
-- Si el DNI es null devuelve NULL
-- Esa funcion debe aceptar más argumentos:
-- - dni IN VARCHAR2
-- - si quiero rellenar con ceros                  -> Podeis echar un ojo a la función LPAD (no es obligatorio)
-- - si quiero separar con guiones o espacios o nada
-- - si quiero la letra en mayúsculas (UPPER) o minúsculas (LOWER)
-- - si quiero puntos en el número o no --- Esta en version 1 no!


-- SELECT normalizar_dni('12345678Z', 1, '-', 1) AS dni_normalizado FROM DUAL;

CREATE OR REPLACE FUNCTION normalizar_dni (
    dni                 IN VARCHAR2,
    rellenar_con_ceros  IN NUMBER   DEFAULT 1,
    separador           IN VARCHAR2 DEFAULT '',
    letra_mayuscula     IN NUMBER   DEFAULT 1,
    puntos_en_numero    IN NUMBER   DEFAULT 0
) RETURN VARCHAR2
IS
    dni_valido          BOOLEAN;
    dni_numero          NUMBER(8);
    dni_letra           CHAR(1);
    letra_normalizada   CHAR(1);
    numero_normalizado  VARCHAR2(11);
BEGIN
    validar_dni(dni, dni_valido, dni_numero, dni_letra);
    IF NOT dni_valido THEN
        RETURN NULL;
    END IF;
    -- Aquí realmente es donde normalizo el valor del DNI

    -- Normalización del número:
    numero_normalizado := TO_CHAR(dni_numero);
    -- Aplicar relleno con ceros a la izquierda si se ha pedido
    --IF rellenar_con_ceros = 1 THEN
        -- Opción 1                      0000000123
        -- Siempre le pongo delante 7 ceros y luego corto los que sobren
        -- numero_normalizado := SUBSTR('0000000' || numero_normalizado, -8, 8); -- Coge 8 (8), desde los 8 últimos (-8)
        -- Opción 2
    --    numero_normalizado := LPAD(numero_normalizado, 8, '0'); -- Rellenar por la izquierda hasta tener 8 caracteres con ceros
                                                                -- Otra función a conocer, similar es RPAD (rellena por la derecha)
    -- END IF;
    -- Aplicar los separadores de miles y millones
    IF puntos_en_numero = 1 THEN
        IF rellenar_con_ceros = 1 THEN
            numero_normalizado := TO_CHAR(dni_numero, '00G000G000');
        ELSE
            numero_normalizado := TO_CHAR(dni_numero, '99G999G999');
        END IF;
    ELSE 
        IF rellenar_con_ceros = 1 THEN
            numero_normalizado := LPAD(numero_normalizado, 8, '0');
        END IF;
    END IF;


    -- Normalización de la letra:

    -- OPCION 1, que ya conocíamos!
    -- IF letra_mayuscula = 1 THEN                   -- trabaja a nivel de statement: Es decir, lo que pongo dentro de las condiciones
    --                                           -- es un statement. Por ejemplo, en este caso hago una asignación
    --    letra_normalizada := UPPER(dni_letra);
    -- ELSE
    --    letra_normalizada := LOWER(dni_letra);
    -- END IF;
    -- OPCION 2: CASE:
    letra_normalizada := CASE                    -- trabaja a nivel de expresión: Lo que pongo dentro del CASE es una expresión
                                                 -- lo que asignamos en nuestro caso es el resultado de la expresión (CASE)
                             WHEN letra_mayuscula = 1 THEN UPPER(dni_letra)
                             ELSE LOWER(dni_letra)
                         END;


    -- empaqueto todo para devolverlo
    RETURN numero_normalizado || separador || letra_normalizada;
END;
/
-- SELECT nombre, apellidos, normalizar_dni(dni) AS dni_normalizado 
-- FROM Personas_A_Cargar 
-- WHERE es_dni_valido(dni) = 1;




-- Patrón de un dni? regex101 (Web para verificar expresiones regulares)
-- ^(([0-9]{1,8})|([0-9]{1,2}([.][0-9]{3}){2})|([0-9]{1,3}[.][0-9]{3}))[ -]?[A-Za-z]$
-- [0-9]{1,8} -- 23000000
-- [0-9]{1,2}([.][0-9]{3}){2} -- 23.000.000     2.300.000
-- [0-9]{1,3}[.][0-9]{3}-- 23.000T
-- Al crear un patrón de regex:
-- - Un patron es una secuencia de subpatrones
-- - Cada subpatrón es:
--   - Una secuencia de caracteres
--       - hola           En el texto debe aparecer 'hola'
--       - [hola]         En el texto debe aparecer cualquier letra de las que hay entre corchetes
--       - [a-zA-Z]       En el texto debe aparecer cualquier letra mayúscula o minúscula
--       - [0-9]          En el texto debe aparecer cualquier dígito
--       - [^hola]        En el texto NO debe aparecer ninguna letra de las que hay entre corchetes
--       - .              En el texto puede aparecer cualquier carácter
--   - Seguido de un modificador de cantidad
--       - No poner nada  Aparece exactamente 1 vez
--       - ?              Aparece 0 o 1 veces
--       - +              Aparece 1 o más veces
--       - *              Aparece 0 o más veces
--       - {n}            Aparece exactamente n veces
--       - {n,}           Aparece n o más veces
--       - {n,m}          Aparece entre n y m veces
-- Otros operadores:
--   - ^              Indica el inicio del texto
--   - $              Indica el final del texto
--   - ()             Agrupa subpatrones
--   - |              Operador OR entre subpatrones

-- Relación nxm entre profesores y cursos

CREATE TABLE Profesores_Cursos (
    PROFESOR_ID    NUMBER      NOT NULL,
    CURSO_ID       NUMBER      NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Profesores_Cursos PRIMARY KEY (PROFESOR_ID, CURSO_ID),
    CONSTRAINT FK_Profesores_Cursos_Profesor FOREIGN KEY (PROFESOR_ID) REFERENCES Profesores(ID),
    CONSTRAINT FK_Profesores_Cursos_Curso FOREIGN KEY (CURSO) REFERENCES Cursos(ID)
);

-- Tabla Empresas

-- ID, Nombre, CIF, Dirección, Teléfono, Email
-- Una empresa debe tener al menos un número de teléfono... aunque puede tener varios

CREATE TABLE Empresas (
    ID              NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE          VARCHAR2(100)   NOT NULL,
    CIF             VARCHAR2(20)    NOT NULL, 
    DIRECCION       VARCHAR2(2000),
    EMAIL           VARCHAR2(100), 

 -- CONSTRAINS
    CONSTRAINT PK_Empresas PRIMARY  KEY (ID),
    CONSTRAINT UQ_Empresas_CIF      UNIQUE (CIF)
);
-- TODO: Nos falta 3 regex:
-- - Validar CIF (LETRAS Y NÚMEROS)
-- - Validar Email (Este es facil... en internet encontraréis muchos ejemplos)
-- - Validar Teléfono: (números, -, espacio, paréntesis y el +)
--   - MINIMO: +(192) 922 99 23 93
--   - GUAY: Hacer una validación un poco más exhaustiva y normalizar el teléfono, igual que hemos hecho con el DNI

-- Os lo dejo de regalo!
-- Mañana doy la solución
-- Al menos un mínimo!


CREATE TABLE Empresas_Telefonos (
    EMPRESA_ID     NUMBER       NOT NULL,
    TELEFONO       VARCHAR2(20) NOT NULL, 

 -- CONSTRAINS
    CONSTRAINT PK_Empresas_Telefonos PRIMARY KEY (EMPRESA_ID, TELEFONO),
    CONSTRAINT FK_Empresas_Telefonos_Empresa FOREIGN KEY (EMPRESA_ID) REFERENCES Empresas(ID) ON DELETE CASCADE
    -- ON DELETE CASCADE: Si se borra una empresa, se borran todos sus teléfonos asociados automáticamente
    -- Como se aplican los delete on cascade? Cuál es el orden de ejecución?
    -- 1. Se borra la empresa
    -- 2. Y después se borran todos los teléfonos asociados a esa empresa
    -- O:
    -- 1. Se borran todos los teléfonos asociados a esa empresa
    -- 2. Y después se borra la empresa
    -- La respuesta es la opción 2
    -- Y tenemos un probolemón.
);

-- Como resolvemos la restricción de que una empresa debe tener al menos un teléfono?
-- No hay nada en SQL puro que lo permita.

-- Esto es territorio de PL/SQL.
-- Vamos a hacer que no se pueda insertar nada directamente en la tabla Empresas.

REVOKE INSERT ON Empresas FROM PUBLIC; -- Aqui el usuario para el que revocamos el permiso es PUBLIC, es decir, todos los usuarios

-- En su lugar, vamos a ofrecer como alternativa un procedimiento almacenado que haga el INSERT en Empresas y en Empresas_Telefonos

-- Opción 1: Exigir un teléfono en el procedimiento de creación
CREATE OR REPLACE PROCEDURE crear_empresa_con_telefono (
    p_nombre        IN VARCHAR2,
    p_cif           IN VARCHAR2,
    p_direccion     IN VARCHAR2,
    p_email         IN VARCHAR2,
    p_telefono      IN VARCHAR2
) IS
    -- variables locales
    nueva_empresa_id   NUMBER;
BEGIN

    -- Para poder hacer un rollback en caso de error al introducir el teléfono
    -- Vamos a hacer un SAVEPOINT
    SAVEPOINT antes_de_crear_empresa; -- Esto es un punto al que puedo volver si hay un error

    INSERT INTO Empresas (NOMBRE, CIF, DIRECCION, EMAIL)
    VALUES (p_nombre, p_cif, p_direccion, p_email)
    RETURNING ID INTO nueva_empresa_id;

    INSERT INTO Empresas_Telefonos (EMPRESA_ID, TELEFONO)
    VALUES (nueva_empresa_id, p_telefono);
-- Ahora puedo indicar el tratamiento que quiero implementar en caso de error
EXCEPTION
    WHEN OTHERS THEN -- Aqui podría poner el tipo de error específico que quiero capturar
                     -- Pero en este caso, me da igual el tipo de error
                     -- Cualquier error que se produzca en los inserts lo capturo aquí
        -- Si hay cualquier error, volvemos al savepoint
        ROLLBACK TO antes_de_crear_empresa;
        -- Y re-lanzamos el error para que el usuario se entere
        RAISE; -- que al usuario le llegue exactamente el mismo error que se ha producido
END;

-- Esto no solo nos mete la restricción que queremos implementar.
-- Tiene otra ventaja: Esto va más rápido que hacer 2 inserts desde la aplicación cliente.
-- Si hago 2 inserts, por qué va más lento?
-- - Solo tengo que ir a la BBDD una sola vez. Me quito latencia de las comunicaciones.
-- - Cuando lanzo una query a la BBDD que es lo primero que hace la BBDD?
--   Parsear la query: Analizarla sintácticamente, ver si es correcta
--   Validar los datos que se usan en la query (columnas) (existen, los tipos de datos coinciden, ???)
--   Generar un plan de ejecución
-- Al meterlo en un procedimiento almacenado, el código se compila, y se preparan planes de ejecución que se cachean.

-- Esto va guay. Ya una persona no puede bajo ningún escenario dar de alta una empresa sin teléfono.
-- Pero... podría una persona, una vez creada la empresa, borrar todos los teléfonos asociados a esa empresa?
-- Sí, podría. Y ESO ES UN PROBLEMA.

-- Podríamos hacer un procedimiento almacenado para borrar teléfonos de una empresa
-- Y hacer un revoke delete on Empresas_Telefonos from public   
-- Es matar moscas a cañonazos!

-- Otra opción es meter un trigger en la tabla Empresas_Telefonos
-- Que verifique, en cada delete, que la empresa sigue teniendo al menos un teléfono
-- Si no tiene ninguno, que lance un error y no deje hacer el delete

CREATE OR REPLACE TRIGGER TRG_Empresas_Telefonos_Al_Menos_Uno
BEFORE DELETE ON Empresas_Telefonos
FOR EACH ROW
DECLARE
    numero_telefonos   NUMBER;
BEGIN
    -- Contar cuántos teléfonos tiene la empresa a la que pertenece el teléfono que se va a borrar
    SELECT COUNT(*) INTO numero_telefonos
    FROM Empresas_Telefonos
    WHERE EMPRESA_ID = :OLD.EMPRESA_ID; -- :OLD porque estamos en un DELETE

    -- Si solo tiene uno teléfono, no dejamos borrar ese teléfono
    IF numero_telefonos <= 1 THEN -- Necesitamos evitar que este IF se ejecute 
                                  -- Si estamos borrando la empresa
                                  -- Necesitamos de alguna forma saber si se está borrando la empresa
                                  -- Ese es el único motivo por el que estaría bien borrar el último teléfono
                                  -- Necesito algun flag que me indique si se está borrando la empresa
                                  -- Como podemos implementar ese flag?
                                  -- Podríamos usar una variable de paquete
        RAISE_APPLICATION_ERROR(-20002, 'Toda empresa debe tener al menos un teléfono.');
    END IF;
END;
/
-- Qué es un Paquete en PL/SQL?
-- Un paquete es un contenedor lógico de código PL/SQL
-- Un paquete tiene 2 partes:
-- - Especificación del paquete: Declaraciones públicas (visibles desde fuera del paquete)
-- - Cuerpo del paquete: Implementación del código (código privado, no visible desde fuera del paquete, y código público, visible desde fuera del paquete)
-- En la especificación del paquete podemos declarar variables, constantes, tipos de datos, cursores, procedimientos y funciones
-- En el cuerpo del paquete implementamos los procedimientos y funciones declarados en la especificación
-- Por ahora, solo usaremos paquetes para declarar variables globales (visibles desde cualquier trigger o procedimiento almacenado)

CREATE OR REPLACE PACKAGE pkg_empresas IS
    borrando_empresa   BOOLEAN := FALSE; -- Variable para indicar si se está borrando una empresa
END pkg_empresas;

-- Ahora modificamos el trigger de borrado de teléfonos para que use esa variable

CREATE OR REPLACE TRIGGER TRG_Empresas_Telefonos_Al_Menos_Uno
BEFORE DELETE ON Empresas_Telefonos
FOR EACH ROW
DECLARE
    numero_telefonos   NUMBER;
BEGIN
    IF pkg_empresas.borrando_empresa THEN
        RETURN; -- Si se está borrando la empresa, no hacemos nada
    END IF;

    -- Contar cuántos teléfonos tiene la empresa a la que pertenece el teléfono que se va a borrar
    SELECT COUNT(*) INTO numero_telefonos
    FROM Empresas_Telefonos
    WHERE EMPRESA_ID = :OLD.EMPRESA_ID; -- :OLD porque estamos en un DELETE

    -- Si solo tiene uno teléfono, no dejamos borrar ese teléfono
    IF numero_telefonos <= 1 THEN -- Necesitamos evitar que este IF se ejecute 
                                  -- Si estamos borrando la empresa
                                  -- Necesitamos de alguna forma saber si se está borrando la empresa
                                  -- Ese es el único motivo por el que estaría bien borrar el último teléfono
                                  -- Necesito algun flag que me indique si se está borrando la empresa
                                  -- Como podemos implementar ese flag?
                                  -- Podríamos usar una variable de paquete
        RAISE_APPLICATION_ERROR(-20002, 'Toda empresa debe tener al menos un teléfono.');
    END IF;
END;
/
-- Esa variable ahora puedo establecerla en un trigger de borrado de la tabla Empresas

-- CREATE OR REPLACE TRIGGER TRG_Empresas_Borrado
-- BEFORE DELETE ON Empresas
-- FOR EACH ROW
-- BEGIN
    -- Indicar que se está borrando una empresa
    -- pkg_empresas.borrando_empresa := TRUE;
-- END;
-- /
-- Y ahora, para que todo vuelva a la normalidad, necesitamos un trigger AFTER DELETE   
-- CREATE OR REPLACE TRIGGER TRG_Empresas_Borrado_After
-- AFTER DELETE ON Empresas
-- FOR EACH ROW
-- BEGIN
    -- Indicar que ya no se está borrando una empresa
   --  pkg_empresas.borrando_empresa := FALSE;
-- END;
-- /

-- En lugar de crear 2 triggers en la tabla Empresas, uno BEFORE DELETE y otro AFTER DELETE
-- Podemos crear un solo trigger de tipo COMPOUND
CREATE OR REPLACE TRIGGER TRG_Empresas_Borrado
FOR DELETE ON Empresas
COMPOUND TRIGGER
    BEFORE STATEMENT IS
    BEGIN
        -- Indicar que se está borrando una empresa
        pkg_empresas.borrando_empresa := TRUE;
    END BEFORE STATEMENT;
    AFTER STATEMENT IS
    BEGIN
        -- Indicar que ya no se está borrando una empresa
        pkg_empresas.borrando_empresa := FALSE;
    END AFTER STATEMENT;
END TRG_Empresas_Borrado;
/

-- Opción 2: Permitir varios teléfonos usando un tipo colección

-- Para esta segunda opción, lo primero que necesito es definir un TIPO de datos, que me permita recibir 
-- muchos teléfonos en un solo parámetro
CREATE OR REPLACE TYPE tipo_telefonos AS TABLE OF VARCHAR2(20);

-- Y ahora podría crear un procedimiento almacenado que reciba ese tipo de datos como parámetro
CREATE OR REPLACE PROCEDURE crear_empresa_con_varios_telefonos (
    p_nombre        IN VARCHAR2,
    p_cif           IN VARCHAR2,
    p_direccion     IN VARCHAR2,
    p_email         IN VARCHAR2,
    p_telefonos     IN tipo_telefonos
) IS
    -- variables locales
    nueva_empresa_id   NUMBER;
BEGIN

    -- Verificar que realmente dentro de esa lista de teléfonos hay al menos un teléfono
    IF p_telefonos IS NULL OR p_telefonos.COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Debe proporcionar al menos un teléfono.');
    END IF;

    -- Para poder hacer un rollback en caso de error al introducir el teléfono
    -- Vamos a hacer un SAVEPOINT
    SAVEPOINT antes_de_crear_empresa; -- Esto es un punto al que puedo volver si hay un error

    INSERT INTO Empresas (NOMBRE, CIF, DIRECCION, EMAIL)
    VALUES (p_nombre, p_cif, p_direccion, p_email)
    RETURNING ID INTO nueva_empresa_id;

    -- Para cada telefono (ahora sé que al menos hay uno) hago el insert. BUCLE!
    FOR i IN 1 .. p_telefonos.COUNT LOOP
        INSERT INTO Empresas_Telefonos (EMPRESA_ID, TELEFONO)
        VALUES (nueva_empresa_id, p_telefonos(i));
    END LOOP;
-- Ahora puedo indicar el tratamiento que quiero implementar en caso de error
EXCEPTION
    WHEN OTHERS THEN -- Aqui podría poner el tipo de error específico que quiero capturar
                     -- Pero en este caso, me da igual el tipo de error
                     -- Cualquier error que se produzca en los inserts lo capturo aquí
        -- Si hay cualquier error, volvemos al savepoint
        ROLLBACK TO antes_de_crear_empresa;
        -- Y re-lanzamos el error para que el usuario se entere
        RAISE; -- que al usuario le llegue exactamente el mismo error que se ha producido
END;

-- Tabla Alumnos (nxm con empresas)
-- Tabla Convocatorias (Curso, Fecha Inicio, Fecha Fin, Estado)

CREATE TABLE Estados_Convocatoria (
    ID          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO      VARCHAR2(20)    NOT NULL,
    NOMBRE      VARCHAR2(100)   NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Estados_Convocatoria PRIMARY KEY (ID),
    CONSTRAINT UQ_Estados_Convocatoria_Codigo UNIQUE (CODIGO),
    CONSTRAINT CHK_Estados_Convocatoria_Codigo_Mayusculas CHECK (REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
);

-- Ejemplos de estados:
-- 1. Abierta
-- 2. Cerrada
-- 3. Impartiéndose
-- 4. Cancelada
-- 5. Finalizada

CREATE TABLE Convocatorias (
    ID             NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CURSO_ID       NUMBER          NOT NULL,
    FECHA_INICIO   DATE            NOT NULL,
    FECHA_FIN      DATE            NOT NULL,
    ESTADO_ID      NUMBER          NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Convocatorias PRIMARY         KEY (ID),
    CONSTRAINT FK_Convocatorias_Curso FOREIGN   KEY (CURSO_ID)      REFERENCES Cursos(ID),
    CONSTRAINT FK_Convocatorias_Estado FOREIGN  KEY (ESTADO_ID)     REFERENCES Estados_Convocatoria(ID),
    CONSTRAINT CHK_Convocatorias_Fechas         CHECK (FECHA_FIN > FECHA_INICIO)
);

-- Más adelante iremos matriculando alumnos en las convocatorias
-- Tabla Matriculas (Alumno, Convocatoria, ...)
-- Alguna restricción que pensáis que vayamnos a aplicar en esta tabla: Matriculas?
-- - Máximo de alumnos matriculados. >> REGLA DE NEGOCIO !!!!!
-- - Que no haya matriculaciones simultáneas (misma persona en convocatorias con misma fecha). >> REGLA DE NEGOCIO !!!!!
-- - Convocatorias para una empresa concreta. >> REGLA DE NEGOCIO !!!!!
-- - No alumno 2 veces en la misma convocatoria <<< UNIQUE
-- - Que solo podamos matricular alumnos en convocatorias que no estén en estado "FINALIZADO" . >> REGLA DE NEGOCIO !!!!!
--   Por otra vía querría permitir la carga de datos saltándose esas restricción? SI --> REGLA DE NEGOCIO !!!!!
--   En una app de gestión, no debería ser posible matricular alumnos en convocatorias finalizadas
--   Pero en un proceso de carga masiva de datos históricos, podría ser necesario saltarse esa restricción
--   No es una restricción que aplique a nivel de base de datos, sino a nivel de aplicación
--   De hecho, podría tener una app pública, donde se apunta usuarios que solo pueden hacerlo si la convocatoria está abierta
--   Y otra app interna de gestión, donde los administradores pueden matricular alumnos siempre y cuando no esté finalizada
--   Para distintas apps puede ser que quiera aplicar distintas reglas de negocio

CREATE TABLE Alumnos (
    ID              NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE          VARCHAR2(50)    NOT NULL,
    APELLIDOS       VARCHAR2(150)   NOT NULL,
    DNI             VARCHAR2(9)     NOT NULL,
    EMAIL           VARCHAR2(100)   NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Alumnos PRIMARY            KEY (ID),
    CONSTRAINT UQ_Alumnos_DNI                UNIQUE (DNI),
    CONSTRAINT UQ_Alumnos_EMAIL              UNIQUE (EMAIL)
    -- Restricciones al DNI aplicadas mediante un TRIGGER (el mismo que para Profesores)
    -- Restricciones al EMAIL aplicadas mediante un TRIGGER (similar al del DNI, pero con regex para emails)
);

-- Contraseña! Cómo la gestiono?
-- Primero, hoy en día... mejor esto se lo dejo a una herramienta experta en gestión de identidades y accesos (IAM).
-- Y a nivel de mi app, solo gestiono tokens de acceso temporales (JWT, OAuth2, OpenID Connect, etc)
-- Eso es lo que HAY QUE HACER

-- Que me pongo cabezón.. Por mis narices gestiono yo la contraseña.
-- Nunca guardo la contraseña encriptada! JAMAS. Si me ganan la máquina y la clave de encriptación, tienen todas las contraseñas.
-- Resultado: NUNCA GUARDO UNA CONTRASEÑA EN BBDD... ni en texto PLANO, ni ENCRIPTADA. NO SE HACE!
-- Lo que podría hacer es guardar un HASH de la contraseña. Una huella!
-- La letra del DNI? Una huella digital, un hash del número del DNI.
-- Algoritmo de huella:
-- Una función que:
-- - Dada una misma entrada siempre produce la misma salida
-- - Hay muy poca probabilidad de que 2 entradas distintas produzcan la misma salida (colisión). Buscamos funciones con % muy bajas de colisión
--   En el caso del DNI la probabilidad de colisión es de 1 entre 23 (solo hay 23 letras posibles) = 4.34%
--   El ministerio ha considerado que la probabilidad de colisión es suficientemente baja como para usar esa función para determinar si alguna persona ha cometido un error al escribir su DNI
-- - El resultado se considera un resumen del dato de entrada. Es decir, no es posible recuperar el dato original a partir de la huella

-- De hecho, un buen sistema de IAM guarda un hash, del hash, del hash (y así unas 1000 veces) de la contraseña.

CREATE TABLE Alumnos_Empresas (
    ALUMNO_ID      NUMBER      NOT NULL,
    EMPRESA_ID     NUMBER      NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Alumnos_Empresas PRIMARY KEY (ALUMNO_ID, EMPRESA_ID),
    CONSTRAINT FK_Alumnos_Empresas_Alumno FOREIGN KEY (ALUMNO_ID) REFERENCES Alumnos(ID),
    CONSTRAINT FK_Alumnos_Empresas_Empresa FOREIGN KEY (EMPRESA_ID) REFERENCES Empresas(ID)
);