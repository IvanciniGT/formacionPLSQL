
-- 
-- Tabla: Tipos de Cursos
--

CREATE TABLE Tipos_Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL,
    DESCRIPCION                 VARCHAR2(4000),

 -- CONSTRAINS
    CONSTRAINT PK_Tipos_Cursos PRIMARY KEY (ID),
    CONSTRAINT UQ_Tipos_Cursos_Codigo UNIQUE (CODIGO)
);

-- 
-- Tabla: Cursos
--

CREATE TABLE Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL,
    DURACION                    NUMBER,
    TIPO                        NUMBER,
    PRECIO_PARA_EMPRESAS        NUMBER,
    PRECIO_PARA_PARTICULARES    NUMBER,
    DESCRIPCION                 VARCHAR2(4000),

 -- CONSTRAINS
    -- Primary Key. Siempre tenemos uno
    CONSTRAINT PK_Cursos PRIMARY                KEY (ID),
    -- Unique: Es nuestro ID PUBLICO
    CONSTRAINT UQ_Cursos_Codigo                 UNIQUE (CODIGO),
                                                -- Este campo, por tener ser una clave única en automático tiene un índice asociado
                                                -- Búsquedas del tipo WHERE CODIGO = 'valor' serán muy rápidas
                                                -- Búsquedas del tipo WHERE CODIGO LIKE 'valor%' serán muy rápidas
    -- Foreign Key hacia Tipos_Cursos
    CONSTRAINT FK_Cursos_Tipo FOREIGN           KEY (TIPO) REFERENCES Tipos_Cursos(ID),
    -- Restricciones al valor de los campos
                                                -- AQUI PONEMOS UNA EXPRESION QUE DEVUELVA UN BOOLEANO
                                                -- Si devuelve TRUE, se acepta el valor
                                                -- Si devuelve FALSE, se rechaza el valor
    CONSTRAINT CHK_Cursos_Duracion              CHECK (DURACION IS NULL OR DURACION > 0),
    CONSTRAINT CHK_Cursos_Precio_Empresas       CHECK (PRECIO_PARA_EMPRESAS IS NULL OR PRECIO_PARA_EMPRESAS >= 0),
    CONSTRAINT CHK_Cursos_Precio_Particulares   CHECK (PRECIO_PARA_PARTICULARES IS NULL OR PRECIO_PARA_PARTICULARES >= 0),
    CONSTRAINT CHK_Cursos_Codigo_Mayusculas     CHECK (CODIGO = UPPER(CODIGO) AND REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
);


-- Notas respecto al campo CODIGO:
-- - Será muy recomendable implementar un AUTOCOMPLETAR en los formularios de búsqueda: ORA-     ora-      Ora-
-- - Podría ser que el usuario escriba minúsculas o mayúsculas de forma indistinta al buscar <- Quiero dar esa opción?
-- - Lo que nos estamos preguntando es: Quiero que el valor de ese campo sea case-sensitive o case-insensitive?
-- - Y en un campo como este, lo guay es que sea case-insensitive
-- - Esa funcionalidad la podríamos implementar en una query : WHERE UPPER(CODIGO) = UPPER('valor_del_usuario')
--                                                             WHERE UPPER(CODIGO) LIKE UPPER('valor_del_usuario') || '%'
--                                                             WHERE UPPER(CODIGO) LIKE '%' || UPPER('valor_del_usuario') || '%'
-- Pregunta?  Me funciona el índice que he creado en esos casos?
-- Respuesta: NO, ya que lo que tengo indexado es el valor del CODIGO... y en la query se usa el UPPER(CODIGO).
--            Y ese valor no está indexado!
-- Esto implica que hay que transformar bajo demanda, en cada query, todos los valores del campo CODIGO a mayúsculas
-- para poder comparar con el valor que ha dado el usuario. EL INDICE SE VUELVE INUTIL!
-- Opciones:
-- 1. Transformar en automático el valor del campo CODIGO a mayúsculas en el momento de hacer el INSERT o el UPDATE
--    Eso lo permite SQL? NO
--    Con un trigger y PL/SQL SÍ
-- 2. Forzar que el campo solo pueda recibir valores en mayúsculas. Limitación al rango de valores aceptables
--    Eso lo permite SQL? SÍ, con un CONSTRAINT CHECK
-- 3. Generar un índice adicional basado en la función UPPER(CODIGO). Índice funcional
--    Eso lo permite SQL? SÍ
--    CREATE INDEX IX_Cursos_Codigo_Upper ON Cursos(UPPER(CODIGO));
--    En este caso, tendríamos 2 índices. Más espacio y más tiempo en los INSERTs/UPDATEs.
--    Y Además, lo que me gustaría es de alguna forma NORMALIZAR el valor del campo CODIGO a mayúsculas.
--    Esto no exige que el campo se almacene en mayúsculas, pero sí que el valor indexado lo esté.
--    En otros escenarios, esto podría ser una solución interesante. En este NO.

-- Entre opción 1 y opción 2, nos quedamos con las 2.
-- La opción 2, es la que asegura que el valor del campo CODIGO siempre estará en mayúsculas.
-- La opción 1, es la que nos permite dar al usuario la flexibilidad de escribir minúsculas o mayúsculas al dar de alta el campo.

-- Implementando eso (o incluso si implementamos la opción 3), las búsquedas que usarán índice serían:
-- WHERE CODIGO = UPPER('VALOR_EN_MAYUSCULAS')
-- WHERE CODIGO LIKE UPPER('VALOR_EN_MAYUSCULAS') || '%'
-- ESTA NO FUNCIONA : WHERE CODIGO LIKE '%' || UPPER('VALOR_EN_MAYUSCULAS') 
--                    La búsqueda sin funcionaría, pero no usaría índice
-- El % al principio en los LIKES impide usar índice. Estas queries deberían estar proscritas en un entorno con grandes volúmenes de datos.
-- A no ser que tenga 200 datos en la tabla, claro.
-- Si quiero búsquedas de ese estilo, o búsquedas que no discrimen por acentos, o que automáticamente ignoren mayúsculas/minúsculas, la solución es otra:
-- - Índices invertidos full text: Oracle Text (eso viene con la propia licencia de Oracle Database), aunque he de activarlo explícitamente y configurarlo


-- Trigger para asegurar que el campo CODIGO siempre se almacena en mayúsculas
CREATE OR REPLACE TRIGGER TRG_Cursos_Codigo_Mayusculas
BEFORE INSERT OR UPDATE ON Cursos
FOR EACH ROW
BEGIN
    -- Solo transformamos el valor si no es NULL
    -- De esta forma evitamos que el trigger falle al intentar transformar un NULL
    -- Si es nulo, lo dejamos como está, es decir NULL
    -- Y ya la restricción NOT NULL definida en la tabla se encargará de rechazarlo si es necesario dando un mensaje adecuado al usuario

    -- En el caso de un UPDATE, si el valor no cambia, el valor :NEW.CODIGO se queda como está, no lo tocamos... y sigue funcionando bien.
    IF :NEW.CODIGO IS NOT NULL THEN 
        :NEW.CODIGO := UPPER(:NEW.CODIGO);
    END IF;
END;
/
-- Nota: El trigger se define con una barra (/) al final para indicar a SQL*Plus que ejecute el bloque PL/SQL.


-- Tabla Profesores:
-- ID, Nombre, Apellidos, DNI


CREATE TABLE Profesores (
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE                      VARCHAR2(50)    NOT NULL,
    APELLIDOS                   VARCHAR2(150)   NOT NULL,
    DNI                         VARCHAR2(9)     NOT NULL,

 -- CONSTRAINS
    -- Primary Key. Siempre tenemos uno
    CONSTRAINT PK_Profesores PRIMARY             KEY (ID),
    -- Unique: Es nuestro ID PUBLICO
    CONSTRAINT UQ_Profesores_DNI                 UNIQUE (DNI)
    -- Restricciones al DNI aplicadas mediante un TRIGGER
);

-- Meteremos un trigger a esa tabla para?
-- - Validar que lo que llega es correcto (formato + letra correcta)
-- - Normalizarlo (quitar puntos y guiones, poner letra en mayúsculas)

CREATE OR REPLACE TRIGGER TRG_Profesores_DNI_Validar_Normalizar
BEFORE INSERT OR UPDATE ON Profesores
FOR EACH ROW
DECLARE
    dni_valido      BOOLEAN;
    dni_numero      NUMBER(8);
    dni_letra       CHAR(1);
BEGIN
    -- Si el DNI Es null, no hacemos nada, y que el propio NOT NULL de la tabla se encargue de rechazarlo
    IF :NEW.DNI IS NULL THEN
        RETURN;
    END IF;
    -- Validar el formato del DNI
    dni_utils.validar_dni(:NEW.DNI, dni_valido, dni_numero, dni_letra);
    IF NOT dni_valido THEN
        RAISE_APPLICATION_ERROR(-20001, 'DNI inválido: ' || :NEW.DNI); -- Este mensaje le saldrá al usuario si el DNI no es válido
    ELSE
        -- Si es válido, normalizar el valor del DNI
        :NEW.DNI := TO_CHAR(dni_numero) || dni_letra; -- Número sin ceros a la izquierda + letra en mayúsculas, sin puntos ni separadores
    END IF;
END;
/

-- Esto estaría acabado! al menos lo referente a la tabla profesores.


-- Relación nxm entre profesores y cursos

CREATE TABLE Profesores_Cursos (
    PROFESOR_ID    NUMBER      NOT NULL,
    CURSO_ID       NUMBER      NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Profesores_Cursos PRIMARY KEY (PROFESOR_ID, CURSO_ID),
    CONSTRAINT FK_Profesores_Cursos_Profesor FOREIGN KEY (PROFESOR_ID) REFERENCES Profesores(ID),
    CONSTRAINT FK_Profesores_Cursos_Curso FOREIGN KEY (CURSO_ID) REFERENCES Cursos(ID)
);

-- Tabla Empresas

-- ID, Nombre, CIF, Dirección, Teléfono, Email
-- Una empresa debe tener al menos un número de teléfono... aunque puede tener varios

CREATE TABLE Empresas (
    ID              NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE          VARCHAR2(100)   NOT NULL,
    CIF             VARCHAR2(20)    NOT NULL, 
    DIRECCION       VARCHAR2(2000),
    EMAIL           VARCHAR2(100), 

 -- CONSTRAINS
    CONSTRAINT PK_Empresas PRIMARY  KEY (ID),
    CONSTRAINT UQ_Empresas_CIF      UNIQUE (CIF)
);
-- TODO: Nos falta 3 regex:
-- - Validar CIF (LETRAS Y NÚMEROS)
-- - Validar Email (Este es facil... en internet encontraréis muchos ejemplos)
-- - Validar Teléfono: (números, -, espacio, paréntesis y el +)
--   - MINIMO: +(192) 922 99 23 93
--   - GUAY: Hacer una validación un poco más exhaustiva y normalizar el teléfono, igual que hemos hecho con el DNI

-- Os lo dejo de regalo!
-- Mañana doy la solución
-- Al menos un mínimo!


CREATE TABLE Empresas_Telefonos (
    EMPRESA_ID     NUMBER       NOT NULL,
    TELEFONO       VARCHAR2(20) NOT NULL, 

 -- CONSTRAINS
    CONSTRAINT PK_Empresas_Telefonos PRIMARY KEY (EMPRESA_ID, TELEFONO),
    CONSTRAINT FK_Empresas_Telefonos_Empresa FOREIGN KEY (EMPRESA_ID) REFERENCES Empresas(ID) ON DELETE CASCADE
    -- ON DELETE CASCADE: Si se borra una empresa, se borran todos sus teléfonos asociados automáticamente
    -- Como se aplican los delete on cascade? Cuál es el orden de ejecución?
    -- 1. Se borra la empresa
    -- 2. Y después se borran todos los teléfonos asociados a esa empresa
    -- O:
    -- 1. Se borran todos los teléfonos asociados a esa empresa
    -- 2. Y después se borra la empresa
    -- La respuesta es la opción 2
    -- Y tenemos un probolemón.
);

-- Como resolvemos la restricción de que una empresa debe tener al menos un teléfono?
-- No hay nada en SQL puro que lo permita.

-- Esto es territorio de PL/SQL.
-- Vamos a hacer que no se pueda insertar nada directamente en la tabla Empresas.

REVOKE INSERT ON Empresas FROM PUBLIC; -- Aqui el usuario para el que revocamos el permiso es PUBLIC, es decir, todos los usuarios

-- En su lugar, vamos a ofrecer como alternativa un procedimiento almacenado que haga el INSERT en Empresas y en Empresas_Telefonos

-- Opción 1: Exigir un teléfono en el procedimiento de creación
CREATE OR REPLACE PROCEDURE crear_empresa_con_telefono (
    p_nombre        IN VARCHAR2,
    p_cif           IN VARCHAR2,
    p_direccion     IN VARCHAR2,
    p_email         IN VARCHAR2,
    p_telefono      IN VARCHAR2
) IS
    -- variables locales
    nueva_empresa_id   NUMBER;
BEGIN

    -- Para poder hacer un rollback en caso de error al introducir el teléfono
    -- Vamos a hacer un SAVEPOINT
    SAVEPOINT antes_de_crear_empresa; -- Esto es un punto al que puedo volver si hay un error

    INSERT INTO Empresas (NOMBRE, CIF, DIRECCION, EMAIL)
    VALUES (p_nombre, p_cif, p_direccion, p_email)
    RETURNING ID INTO nueva_empresa_id;

    INSERT INTO Empresas_Telefonos (EMPRESA_ID, TELEFONO)
    VALUES (nueva_empresa_id, p_telefono);
-- Ahora puedo indicar el tratamiento que quiero implementar en caso de error
EXCEPTION
    WHEN OTHERS THEN -- Aqui podría poner el tipo de error específico que quiero capturar
                     -- Pero en este caso, me da igual el tipo de error
                     -- Cualquier error que se produzca en los inserts lo capturo aquí
        -- Si hay cualquier error, volvemos al savepoint
        ROLLBACK TO antes_de_crear_empresa;
        -- Y re-lanzamos el error para que el usuario se entere
        RAISE; -- que al usuario le llegue exactamente el mismo error que se ha producido
END;

-- Esto no solo nos mete la restricción que queremos implementar.
-- Tiene otra ventaja: Esto va más rápido que hacer 2 inserts desde la aplicación cliente.
-- Si hago 2 inserts, por qué va más lento?
-- - Solo tengo que ir a la BBDD una sola vez. Me quito latencia de las comunicaciones.
-- - Cuando lanzo una query a la BBDD que es lo primero que hace la BBDD?
--   Parsear la query: Analizarla sintácticamente, ver si es correcta
--   Validar los datos que se usan en la query (columnas) (existen, los tipos de datos coinciden, ???)
--   Generar un plan de ejecución
-- Al meterlo en un procedimiento almacenado, el código se compila, y se preparan planes de ejecución que se cachean.

-- Esto va guay. Ya una persona no puede bajo ningún escenario dar de alta una empresa sin teléfono.
-- Pero... podría una persona, una vez creada la empresa, borrar todos los teléfonos asociados a esa empresa?
-- Sí, podría. Y ESO ES UN PROBLEMA.

-- Podríamos hacer un procedimiento almacenado para borrar teléfonos de una empresa
-- Y hacer un revoke delete on Empresas_Telefonos from public   
-- Es matar moscas a cañonazos!

-- Otra opción es meter un trigger en la tabla Empresas_Telefonos
-- Que verifique, en cada delete, que la empresa sigue teniendo al menos un teléfono
-- Si no tiene ninguno, que lance un error y no deje hacer el delete

CREATE OR REPLACE TRIGGER TRG_Empresas_Telefonos_Al_Menos_Uno
BEFORE DELETE ON Empresas_Telefonos
FOR EACH ROW
DECLARE
    numero_telefonos   NUMBER;
BEGIN
    -- Contar cuántos teléfonos tiene la empresa a la que pertenece el teléfono que se va a borrar
    SELECT COUNT(*) INTO numero_telefonos
    FROM Empresas_Telefonos
    WHERE EMPRESA_ID = :OLD.EMPRESA_ID; -- :OLD porque estamos en un DELETE

    -- Si solo tiene uno teléfono, no dejamos borrar ese teléfono
    IF numero_telefonos <= 1 THEN -- Necesitamos evitar que este IF se ejecute 
                                  -- Si estamos borrando la empresa
                                  -- Necesitamos de alguna forma saber si se está borrando la empresa
                                  -- Ese es el único motivo por el que estaría bien borrar el último teléfono
                                  -- Necesito algun flag que me indique si se está borrando la empresa
                                  -- Como podemos implementar ese flag?
                                  -- Podríamos usar una variable de paquete
        RAISE_APPLICATION_ERROR(-20002, 'Toda empresa debe tener al menos un teléfono.');
    END IF;
END;
/
-- Qué es un Paquete en PL/SQL?
-- Un paquete es un contenedor lógico de código PL/SQL
-- Un paquete tiene 2 partes:
-- - Especificación del paquete: Declaraciones públicas (visibles desde fuera del paquete)
-- - Cuerpo del paquete: Implementación del código (código privado, no visible desde fuera del paquete, y código público, visible desde fuera del paquete)
-- En la especificación del paquete podemos declarar variables, constantes, tipos de datos, cursores, procedimientos y funciones
-- En el cuerpo del paquete implementamos los procedimientos y funciones declarados en la especificación
-- Por ahora, solo usaremos paquetes para declarar variables globales (visibles desde cualquier trigger o procedimiento almacenado)

CREATE OR REPLACE PACKAGE pkg_empresas IS
    borrando_empresa   BOOLEAN := FALSE; -- Variable para indicar si se está borrando una empresa
END pkg_empresas;

-- Ahora modificamos el trigger de borrado de teléfonos para que use esa variable

CREATE OR REPLACE TRIGGER TRG_Empresas_Telefonos_Al_Menos_Uno
BEFORE DELETE ON Empresas_Telefonos
FOR EACH ROW
DECLARE
    numero_telefonos   NUMBER;
BEGIN
    IF pkg_empresas.borrando_empresa THEN
        RETURN; -- Si se está borrando la empresa, no hacemos nada
    END IF;

    -- Contar cuántos teléfonos tiene la empresa a la que pertenece el teléfono que se va a borrar
    SELECT COUNT(*) INTO numero_telefonos
    FROM Empresas_Telefonos
    WHERE EMPRESA_ID = :OLD.EMPRESA_ID; -- :OLD porque estamos en un DELETE

    -- Si solo tiene uno teléfono, no dejamos borrar ese teléfono
    IF numero_telefonos <= 1 THEN -- Necesitamos evitar que este IF se ejecute 
                                  -- Si estamos borrando la empresa
                                  -- Necesitamos de alguna forma saber si se está borrando la empresa
                                  -- Ese es el único motivo por el que estaría bien borrar el último teléfono
                                  -- Necesito algun flag que me indique si se está borrando la empresa
                                  -- Como podemos implementar ese flag?
                                  -- Podríamos usar una variable de paquete
        RAISE_APPLICATION_ERROR(-20002, 'Toda empresa debe tener al menos un teléfono.');
    END IF;
END;
/
-- Esa variable ahora puedo establecerla en un trigger de borrado de la tabla Empresas

-- CREATE OR REPLACE TRIGGER TRG_Empresas_Borrado
-- BEFORE DELETE ON Empresas
-- FOR EACH ROW
-- BEGIN
    -- Indicar que se está borrando una empresa
    -- pkg_empresas.borrando_empresa := TRUE;
-- END;
-- /
-- Y ahora, para que todo vuelva a la normalidad, necesitamos un trigger AFTER DELETE   
-- CREATE OR REPLACE TRIGGER TRG_Empresas_Borrado_After
-- AFTER DELETE ON Empresas
-- FOR EACH ROW
-- BEGIN
    -- Indicar que ya no se está borrando una empresa
   --  pkg_empresas.borrando_empresa := FALSE;
-- END;
-- /

-- En lugar de crear 2 triggers en la tabla Empresas, uno BEFORE DELETE y otro AFTER DELETE
-- Podemos crear un solo trigger de tipo COMPOUND
CREATE OR REPLACE TRIGGER TRG_Empresas_Borrado
FOR DELETE ON Empresas
COMPOUND TRIGGER
    BEFORE STATEMENT IS
    BEGIN
        -- Indicar que se está borrando una empresa
        pkg_empresas.borrando_empresa := TRUE;
    END BEFORE STATEMENT;
    AFTER STATEMENT IS
    BEGIN
        -- Indicar que ya no se está borrando una empresa
        pkg_empresas.borrando_empresa := FALSE;
    END AFTER STATEMENT;
END TRG_Empresas_Borrado;
/

-- Opción 2: Permitir varios teléfonos usando un tipo colección

-- Para esta segunda opción, lo primero que necesito es definir un TIPO de datos, que me permita recibir 
-- muchos teléfonos en un solo parámetro
CREATE OR REPLACE TYPE tipo_telefonos AS TABLE OF VARCHAR2(20);

-- Y ahora podría crear un procedimiento almacenado que reciba ese tipo de datos como parámetro
CREATE OR REPLACE PROCEDURE crear_empresa_con_varios_telefonos (
    p_nombre        IN VARCHAR2,
    p_cif           IN VARCHAR2,
    p_direccion     IN VARCHAR2,
    p_email         IN VARCHAR2,
    p_telefonos     IN tipo_telefonos
) IS
    -- variables locales
    nueva_empresa_id   NUMBER;
BEGIN

    -- Verificar que realmente dentro de esa lista de teléfonos hay al menos un teléfono
    IF p_telefonos IS NULL OR p_telefonos.COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Debe proporcionar al menos un teléfono.');
    END IF;

    -- Para poder hacer un rollback en caso de error al introducir el teléfono
    -- Vamos a hacer un SAVEPOINT
    SAVEPOINT antes_de_crear_empresa; -- Esto es un punto al que puedo volver si hay un error

    INSERT INTO Empresas (NOMBRE, CIF, DIRECCION, EMAIL)
    VALUES (p_nombre, p_cif, p_direccion, p_email)
    RETURNING ID INTO nueva_empresa_id;

    -- Para cada telefono (ahora sé que al menos hay uno) hago el insert. BUCLE!
    FOR i IN 1 .. p_telefonos.COUNT LOOP
        INSERT INTO Empresas_Telefonos (EMPRESA_ID, TELEFONO)
        VALUES (nueva_empresa_id, p_telefonos(i));
    END LOOP;
-- Ahora puedo indicar el tratamiento que quiero implementar en caso de error
EXCEPTION
    WHEN OTHERS THEN -- Aqui podría poner el tipo de error específico que quiero capturar
                     -- Pero en este caso, me da igual el tipo de error
                     -- Cualquier error que se produzca en los inserts lo capturo aquí
        -- Si hay cualquier error, volvemos al savepoint
        ROLLBACK TO antes_de_crear_empresa;
        -- Y re-lanzamos el error para que el usuario se entere
        RAISE; -- que al usuario le llegue exactamente el mismo error que se ha producido
END;

-- Tabla Alumnos (nxm con empresas)
-- Tabla Convocatorias (Curso, Fecha Inicio, Fecha Fin, Estado)

CREATE TABLE Estados_Convocatoria (
    ID          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO      VARCHAR2(20)    NOT NULL,
    NOMBRE      VARCHAR2(100)   NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Estados_Convocatoria PRIMARY KEY (ID),
    CONSTRAINT UQ_Estados_Convocatoria_Codigo UNIQUE (CODIGO),
    CONSTRAINT CHK_Estados_Convocatoria_Codigo_Mayusculas CHECK (REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
);

-- Ejemplos de estados:
-- 1. Abierta
-- 2. Cerrada
-- 3. Impartiéndose
-- 4. Cancelada
-- 5. Finalizada

CREATE TABLE Convocatorias (
    ID             NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CURSO_ID       NUMBER          NOT NULL,
    FECHA_INICIO   DATE            NOT NULL,
    FECHA_FIN      DATE            NOT NULL,
    ESTADO_ID      NUMBER          NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Convocatorias PRIMARY         KEY (ID),
    CONSTRAINT FK_Convocatorias_Curso FOREIGN   KEY (CURSO_ID)      REFERENCES Cursos(ID),
    CONSTRAINT FK_Convocatorias_Estado FOREIGN  KEY (ESTADO_ID)     REFERENCES Estados_Convocatoria(ID),
    CONSTRAINT CHK_Convocatorias_Fechas         CHECK (FECHA_FIN >= FECHA_INICIO)
);

-- Más adelante iremos matriculando alumnos en las convocatorias
-- Tabla Matriculas (Alumno, Convocatoria, ...)
-- Alguna restricción que pensáis que vayamnos a aplicar en esta tabla: Matriculas?
-- - Máximo de alumnos matriculados. >> REGLA DE NEGOCIO !!!!!
-- - Que no haya matriculaciones simultáneas (misma persona en convocatorias con misma fecha). >> REGLA DE NEGOCIO !!!!!
-- - Convocatorias para una empresa concreta. >> REGLA DE NEGOCIO !!!!!
-- - No alumno 2 veces en la misma convocatoria <<< UNIQUE
-- - Que solo podamos matricular alumnos en convocatorias que no estén en estado "FINALIZADO" . >> REGLA DE NEGOCIO !!!!!
--   Por otra vía querría permitir la carga de datos saltándose esas restricción? SI --> REGLA DE NEGOCIO !!!!!
--   En una app de gestión, no debería ser posible matricular alumnos en convocatorias finalizadas
--   Pero en un proceso de carga masiva de datos históricos, podría ser necesario saltarse esa restricción
--   No es una restricción que aplique a nivel de base de datos, sino a nivel de aplicación
--   De hecho, podría tener una app pública, donde se apunta usuarios que solo pueden hacerlo si la convocatoria está abierta
--   Y otra app interna de gestión, donde los administradores pueden matricular alumnos siempre y cuando no esté finalizada
--   Para distintas apps puede ser que quiera aplicar distintas reglas de negocio

CREATE TABLE Alumnos (
    ID              NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE          VARCHAR2(50)    NOT NULL,
    APELLIDOS       VARCHAR2(150)   NOT NULL,
    DNI             VARCHAR2(9)     NOT NULL,
    EMAIL           VARCHAR2(100)   NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Alumnos PRIMARY            KEY (ID),
    CONSTRAINT UQ_Alumnos_DNI                UNIQUE (DNI),
    CONSTRAINT UQ_Alumnos_EMAIL              UNIQUE (EMAIL)
    -- Restricciones al DNI aplicadas mediante un TRIGGER (el mismo que para Profesores)
    -- Restricciones al EMAIL aplicadas mediante un TRIGGER (similar al del DNI, pero con regex para emails)
);

CREATE OR REPLACE TRIGGER TRG_Alumnos_DNI_Validar_Normalizar
BEFORE INSERT OR UPDATE ON Alumnos
FOR EACH ROW
DECLARE
    dni_valido      BOOLEAN;
    dni_numero      NUMBER(8);
    dni_letra       CHAR(1);
BEGIN
    -- Si el DNI Es null, no hacemos nada, y que el propio NOT NULL de la tabla se encargue de rechazarlo
    IF :NEW.DNI IS NULL THEN
        RETURN;
    END IF;
    -- Validar el formato del DNI
    dni_utils.validar_dni(:NEW.DNI, dni_valido, dni_numero, dni_letra);
    IF NOT dni_valido THEN
        RAISE_APPLICATION_ERROR(-20001, 'DNI inválido: ' || :NEW.DNI); -- Este mensaje le saldrá al usuario si el DNI no es válido
    ELSE
        -- Si es válido, normalizar el valor del DNI
        :NEW.DNI := TO_CHAR(dni_numero) || dni_letra; -- Número sin ceros a la izquierda + letra en mayúsculas, sin puntos ni separadores
    END IF;
END;
/

-- Contraseña! Cómo la gestiono?
-- Primero, hoy en día... mejor esto se lo dejo a una herramienta experta en gestión de identidades y accesos (IAM).
-- Y a nivel de mi app, solo gestiono tokens de acceso temporales (JWT, OAuth2, OpenID Connect, etc)
-- Eso es lo que HAY QUE HACER

-- Que me pongo cabezón.. Por mis narices gestiono yo la contraseña.
-- Nunca guardo la contraseña encriptada! JAMAS. Si me ganan la máquina y la clave de encriptación, tienen todas las contraseñas.
-- Resultado: NUNCA GUARDO UNA CONTRASEÑA EN BBDD... ni en texto PLANO, ni ENCRIPTADA. NO SE HACE!
-- Lo que podría hacer es guardar un HASH de la contraseña. Una huella!
-- La letra del DNI? Una huella digital, un hash del número del DNI.
-- Algoritmo de huella:
-- Una función que:
-- - Dada una misma entrada siempre produce la misma salida
-- - Hay muy poca probabilidad de que 2 entradas distintas produzcan la misma salida (colisión). Buscamos funciones con % muy bajas de colisión
--   En el caso del DNI la probabilidad de colisión es de 1 entre 23 (solo hay 23 letras posibles) = 4.34%
--   El ministerio ha considerado que la probabilidad de colisión es suficientemente baja como para usar esa función para determinar si alguna persona ha cometido un error al escribir su DNI
-- - El resultado se considera un resumen del dato de entrada. Es decir, no es posible recuperar el dato original a partir de la huella

-- De hecho, un buen sistema de IAM guarda un hash, del hash, del hash (y así unas 1000 veces) de la contraseña.

CREATE TABLE Alumnos_Empresas (
    ALUMNO_ID      NUMBER      NOT NULL,
    EMPRESA_ID     NUMBER      NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Alumnos_Empresas PRIMARY KEY (ALUMNO_ID, EMPRESA_ID),
    CONSTRAINT FK_Alumnos_Empresas_Alumno FOREIGN KEY (ALUMNO_ID) REFERENCES Alumnos(ID),
    CONSTRAINT FK_Alumnos_Empresas_Empresa FOREIGN KEY (EMPRESA_ID) REFERENCES Empresas(ID)
);

-- Matriculas
CREATE TABLE Estados_Matricula (
    ID          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO      VARCHAR2(20)    NOT NULL,
    NOMBRE      VARCHAR2(100)   NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Estados_Matricula PRIMARY KEY (ID),
    CONSTRAINT UQ_Estados_Matricula_Codigo UNIQUE (CODIGO),
    CONSTRAINT CHK_Estados_Matricula_Codigo_Mayusculas CHECK (REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
);

-- Alumno_ID, Empresa_ID, Convocatoria_ID, Estado_ID, Fecha_Matricula, Precio, Descuento, Precio_Final
CREATE TABLE Matriculas (
    ID               NUMBER      GENERATED BY DEFAULT AS IDENTITY,
    ALUMNO_ID        NUMBER      NOT NULL,
    EMPRESA_ID       NUMBER,
    CONVOCATORIA_ID  NUMBER      NOT NULL,
    ESTADO_ID        NUMBER      NOT NULL,
    FECHA_MATRICULA  DATE        NOT NULL,
    PRECIO           NUMBER(10,2) NOT NULL,
    DESCUENTO        NUMBER(5,2)  NOT NULL,
    PRECIO_FINAL     NUMBER(10,2) NOT NULL,

 -- CONSTRAINS
    -- Primary Key compuesta por los 3 campos
    CONSTRAINT PK_Matriculas PRIMARY KEY (ID), -- Ahora haremos algún comentario
    CONSTRAINT UNIQUE_Matriculas UNIQUE (ALUMNO_ID, EMPRESA_ID, CONVOCATORIA_ID), -- Ahora haremos algún comentario
    -- Foreign Keys
    -- Convocatoria
    CONSTRAINT FK_Matriculas_Convocatoria FOREIGN KEY (CONVOCATORIA_ID) REFERENCES Convocatorias(ID),
    -- Alumnos
    CONSTRAINT FK_Matriculas_Alumno FOREIGN KEY (ALUMNO_ID) REFERENCES Alumnos(ID),
    -- Empresas
    -- CONSTRAINT FK_Matriculas_Empresa FOREIGN KEY (EMPRESA_ID) REFERENCES Empresas(ID),
    -- Error: No puedo meter cualquier empresa. Solamente empresas para las que el alumno esté asociado/registrado en Alumnos_Empresas
    -- ESTA ES LA OPCIÓN BUENA:
    CONSTRAINT FK_Matriculas_Empresa FOREIGN KEY (ALUMNO_ID, EMPRESA_ID) 
        REFERENCES Alumnos_Empresas(ALUMNO_ID, EMPRESA_ID),
    -- El tratamiento que hace la BBDD cuando un campo FK es NULL es no aplicar la restricción
    -- Estado
    CONSTRAINT FK_Matriculas_Estado FOREIGN KEY (ESTADO_ID) REFERENCES Estados_Matricula(ID),
    -- CONTRAINS SOBRE LOS RANGOS DE LOS DATOS:
    CONSTRAINT CHK_Matriculas_Precio_Positive CHECK (PRECIO >= 0),
    CONSTRAINT CHK_Matriculas_Descuento_Range CHECK (DESCUENTO >= 0 AND DESCUENTO <= 100),
    CONSTRAINT CHK_Matriculas_Precio_Final_Positive CHECK (PRECIO_FINAL >= 0)
);

-- CONSTRAINT PK_Matriculas PRIMARY KEY (ALUMNO_ID, EMPRESA_ID, CONVOCATORIA_ID), -- Ahora haremos algún comentario
-- Por que he dicho que iba a hacer algunos comentarios aquí?
-- Si la empresa es Null, no hay problema, porque la PK sigue siendo única, incluyendo el NULL

-- Que estamos haciendo con esa línea? Cuál es su impacto real dentro de la BBDD?
-- - En automático Oracle va a generar un ÍNDICE único para esa PK
-- - Ese índice me interesa? Quiero decir... Entiendo que oracle cuando voy a dar una de alta una matrícula mira rápidito en ese índice 
-- - si ya existe esa matrícula para dar un "unique constraint violation"
-- - La pregunta es... se usará ese indice en mis búsquedas?
--   Por ejemplo: "Dame todos los alumnos que están matriculados en esta convocatoria"
--      SELECT * FROM Matriculas WHERE CONVOCATORIA_ID = 1234;
--   No se usaría por Oracle, ya que el orden del índice es (ALUMNO_ID, EMPRESA_ID, CONVOCATORIA_ID)
--   En esa query estoy entrando por CONVOCATORIA_ID, que es el tercer campo del índice. No vale para nada ese índice en esa query
--   Si hago esta query:
--      SELECT * FROM Matriculas WHERE ALUMNO_ID = 5678 
--   Sí se usaría el índice, ya que estoy entrando por el primer campo del índice
--   Eso lo tengo que tener en cuenta... e intentar adivinar el principal patrón de acceso a los datos que voy a tener pasa esa tabla
--   Siempre podré crear más índices a futuro... pero cuantos índices más cree, más espacio en disco voy a usar y más lentas serán las operaciones de INSERT/UPDATE/DELETE
--   Decisiones:
--    - Entraré principalmente por alumno? Dame todas las matrículas de un alumno
--    - Entraré principalmente por convocatoria? Dame todas las matrículas de una convocatoria
--    - Entraré principalmente por empresa? Dame todas las matrículas de una empresa
-- Es jugarmela!
-- Y posiblemente acabe creando varios índices.

-- Otra nota. Tenemos muchos foreign keys en esta tabla.
-- Genera Oracle índices para los foreign keys? NO
--   Caso que haya muchas consultas (JOINS) que usen esos foreign keys, me interesará crear índices para esos foreign keys


-- EVALUACIONES (Imagina que solo quiero la evaluación final... puede ser que se vayan metiendo notas parciales, pero al final solo quiero guardar la nota final)
-- MATRICULA_ID, FECHA_EVALUACION, NOTA, OBSERVACIONES
-- Pero.. solo quiero guardar el último valor

-- Como es la relación entre Matriculas y Evaluaciones?
-- 1 x 1 . Teníamos ya ejemplos de relaciones 1xn, de relaciones nxm... pero 1x1 no.
-- Aunque.. tiene esto sentido? Quiero decir...
-- Por qué no meter estos campos directamente en la tabla Matriculas? PUEDO METERLOS ALLI, ya que es 1x1
-- Por qué leches entonces no los meto allí y me quito de crear otra tabla... y sus relaciones y mierdecillas... si al final es 1x1?

-- Con qué frecuencia cambian los datos de una matricula en la tabla Matriculas? POCA...
-- Con qué frecuencia cambian los datos de evaluación? MÁS A MENUDO...
-- En general no me interesa mucho mezclar campos que cambian poco con campos que cambian más a menudo
-- Eso me hace un destrozo en las tablas. De este tema hablaremos también más despacio en el curso de ADMINISTRACIÓN DE BASES DE DATOS

-- Cuando modifico una fila, o cuando la borro, realmente El dato no se borra físicamente de disco.. solo se marca como borrado
-- En una modificación puede pasar que el campo observaciones pase de tener 10 caracteres a tener 100 caracteres.
-- Y ese espacio no esta reservado en la fila original, que se guardaba dentro de un bloque de datos(página)
-- En el mejor escenario, si hay espacio libre en el bloque de datos, se mete allí. Si no hay hueco ya en el bloque de datos, 
-- Y acabará no habiendo espacio en el bloque de datos, se tendrá que mover la fila a otro bloque de datos.
-- Pero eso de "mover la fila" es un eufemismo. Lo que realmente pasa es:
-- - Se marca la fila original como borrada (no se borra físicamente, solo se marca como borrada). Sigue allí ocupando espacio.
-- - Se crea una nueva fila en otro bloque de datos con el nuevo valor... y es necesario refrescar TODOS los índices donde esa fila estaba referenciada
--   para que apunten a la nueva ubicación de la fila
-- Esto hay que tenerlo en cuenta. Sobre todo cuando hay campos de tipo VARCHAR2, CLOB, BLOB, cuyos tamaños puedan variar mucho (como es el caso de nuestras evaluaciones: Observaciones)
-- me interesa esos campos llevarmelos a otra tabla, para evitar ese tipo de problemas en la tabla principal (Matriculas)
-- Esto mejora un huevo el rendimiento de las operaciones de UPDATE en la tabla Matriculas y nos libera de muchas complicaciones en el mantenimiento de la BBDD.
-- A las tablas, de vez en cuando hay que pegarles un repasito: OPTIMIZE TABLE Matriculas; 
-- O VACUUM en Postgres, o REORGANIZE en SQL Server, etc
-- Comprime la tabla, elimina filas marcadas como borradas, junta fragmentos, etc
-- Cuantos menos datos tenga, mejor! Con menos frecuencia tendré que hacer ese mantenimiento

CREATE TABLE Evaluaciones (
    MATRICULA_ID     NUMBER      NOT NULL,
    FECHA_EVALUACION DATE        NOT NULL,
    NOTA             NUMBER(5,2) NOT NULL,
    OBSERVACIONES    VARCHAR2(2000),

 -- CONSTRAINS
    CONSTRAINT PK_Evaluaciones PRIMARY KEY (MATRICULA_ID),
    CONSTRAINT FK_Evaluaciones_Matricula FOREIGN KEY (MATRICULA_ID) REFERENCES Matriculas(ID),
    CONSTRAINT CHK_Evaluaciones_Nota_Range CHECK (NOTA >= 0 AND NOTA <= 10)
);