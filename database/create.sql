
-- 
-- Tabla: Tipos de Cursos
--

CREATE TABLE Tipos_Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL,
    DESCRIPCION                 VARCHAR2(4000),

 -- CONSTRAINS
    CONSTRAINT PK_Tipos_Cursos PRIMARY KEY (ID),
    CONSTRAINT UQ_Tipos_Cursos_Codigo UNIQUE (CODIGO)
);

-- 
-- Tabla: Cursos
--

CREATE TABLE Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL,
    DURACION                    NUMBER,
    TIPO                        NUMBER,
    PRECIO_PARA_EMPRESAS        NUMBER,
    PRECIO_PARA_PARTICULARES    NUMBER,
    DESCRIPCION                 VARCHAR2(4000),

 -- CONSTRAINS
    -- Primary Key. Siempre tenemos uno
    CONSTRAINT PK_Cursos PRIMARY                KEY (ID),
    -- Unique: Es nuestro ID PUBLICO
    CONSTRAINT UQ_Cursos_Codigo                 UNIQUE (CODIGO),
                                                -- Este campo, por tener ser una clave única en automático tiene un índice asociado
                                                -- Búsquedas del tipo WHERE CODIGO = 'valor' serán muy rápidas
                                                -- Búsquedas del tipo WHERE CODIGO LIKE 'valor%' serán muy rápidas
    -- Foreign Key hacia Tipos_Cursos
    CONSTRAINT FK_Cursos_Tipo FOREIGN           KEY (TIPO) REFERENCES Tipos_Cursos(ID),
    -- Restricciones al valor de los campos
                                                -- AQUI PONEMOS UNA EXPRESION QUE DEVUELVA UN BOOLEANO
                                                -- Si devuelve TRUE, se acepta el valor
                                                -- Si devuelve FALSE, se rechaza el valor
    CONSTRAINT CHK_Cursos_Duracion              CHECK (DURACION IS NULL OR DURACION > 0),
    CONSTRAINT CHK_Cursos_Precio_Empresas       CHECK (PRECIO_PARA_EMPRESAS IS NULL OR PRECIO_PARA_EMPRESAS >= 0),
    CONSTRAINT CHK_Cursos_Precio_Particulares   CHECK (PRECIO_PARA_PARTICULARES IS NULL OR PRECIO_PARA_PARTICULARES >= 0)
    CONSTRAINT CHK_Cursos_Codigo_Mayusculas     CHECK (CODIGO = UPPER(CODIGO) AND REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
);


-- Notas respecto al campo CODIGO:
-- - Será muy recomendable implementar un AUTOCOMPLETAR en los formularios de búsqueda: ORA-     ora-      Ora-
-- - Podría ser que el usuario escriba minúsculas o mayúsculas de forma indistinta al buscar <- Quiero dar esa opción?
-- - Lo que nos estamos preguntando es: Quiero que el valor de ese campo sea case-sensitive o case-insensitive?
-- - Y en un campo como este, lo guay es que sea case-insensitive
-- - Esa funcionalidad la podríamos implementar en una query : WHERE UPPER(CODIGO) = UPPER('valor_del_usuario')
--                                                             WHERE UPPER(CODIGO) LIKE UPPER('valor_del_usuario') || '%'
--                                                             WHERE UPPER(CODIGO) LIKE '%' || UPPER('valor_del_usuario') || '%'
-- Pregunta?  Me funciona el índice que he creado en esos casos?
-- Respuesta: NO, ya que lo que tengo indexado es el valor del CODIGO... y en la query se usa el UPPER(CODIGO).
--            Y ese valor no está indexado!
-- Esto implica que hay que transformar bajo demanda, en cada query, todos los valores del campo CODIGO a mayúsculas
-- para poder comparar con el valor que ha dado el usuario. EL INDICE SE VUELVE INUTIL!
-- Opciones:
-- 1. Transformar en automático el valor del campo CODIGO a mayúsculas en el momento de hacer el INSERT o el UPDATE
--    Eso lo permite SQL? NO
--    Con un trigger y PL/SQL SÍ
-- 2. Forzar que el campo solo pueda recibir valores en mayúsculas. Limitación al rango de valores aceptables
--    Eso lo permite SQL? SÍ, con un CONSTRAINT CHECK
-- 3. Generar un índice adicional basado en la función UPPER(CODIGO). Índice funcional
--    Eso lo permite SQL? SÍ
--    CREATE INDEX IX_Cursos_Codigo_Upper ON Cursos(UPPER(CODIGO));
--    En este caso, tendríamos 2 índices. Más espacio y más tiempo en los INSERTs/UPDATEs.
--    Y Además, lo que me gustaría es de alguna forma NORMALIZAR el valor del campo CODIGO a mayúsculas.
--    Esto no exige que el campo se almacene en mayúsculas, pero sí que el valor indexado lo esté.
--    En otros escenarios, esto podría ser una solución interesante. En este NO.

-- Entre opción 1 y opción 2, nos quedamos con las 2.
-- La opción 2, es la que asegura que el valor del campo CODIGO siempre estará en mayúsculas.
-- La opción 1, es la que nos permite dar al usuario la flexibilidad de escribir minúsculas o mayúsculas al dar de alta el campo.

-- Implementando eso (o incluso si implementamos la opción 3), las búsquedas que usarán índice serían:
-- WHERE CODIGO = UPPER('VALOR_EN_MAYUSCULAS')
-- WHERE CODIGO LIKE UPPER('VALOR_EN_MAYUSCULAS') || '%'
-- ESTA NO FUNCIONA : WHERE CODIGO LIKE '%' || UPPER('VALOR_EN_MAYUSCULAS') 
--                    La búsqueda sin funcionaría, pero no usaría índice
-- El % al principio en los LIKES impide usar índice. Estas queries deberían estar proscritas en un entorno con grandes volúmenes de datos.
-- A no ser que tenga 200 datos en la tabla, claro.
-- Si quiero búsquedas de ese estilo, o búsquedas que no discrimen por acentos, o que automáticamente ignoren mayúsculas/minúsculas, la solución es otra:
-- - Índices invertidos full text: Oracle Text (eso viene con la propia licencia de Oracle Database), aunque he de activarlo explícitamente y configurarlo


-- Trigger para asegurar que el campo CODIGO siempre se almacena en mayúsculas
CREATE OR REPLACE TRIGGER TRG_Cursos_Codigo_Mayusculas
BEFORE INSERT OR UPDATE ON Cursos
FOR EACH ROW
BEGIN
    -- Solo transformamos el valor si no es NULL
    -- De esta forma evitamos que el trigger falle al intentar transformar un NULL
    -- Si es nulo, lo dejamos como está, es decir NULL
    -- Y ya la restricción NOT NULL definida en la tabla se encargará de rechazarlo si es necesario dando un mensaje adecuado al usuario

    -- En el caso de un UPDATE, si el valor no cambia, el valor :NEW.CODIGO se queda como está, no lo tocamos... y sigue funcionando bien.
    IF :NEW.CODIGO IS NOT NULL THEN 
        :NEW.CODIGO := UPPER(:NEW.CODIGO);
    END IF;
END;
/
-- Nota: El trigger se define con una barra (/) al final para indicar a SQL*Plus que ejecute el bloque PL/SQL.


-- Tabla Profesores:
-- ID, Nombre, Apellidos, DNI


CREATE TABLE Profesores (
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE                      VARCHAR2(50)    NOT NULL,
    APELLIDOS                   VARCHAR2(150)   NOT NULL,
    DNI                         VARCHAR2(9)     NOT NULL,

 -- CONSTRAINS
    -- Primary Key. Siempre tenemos uno
    CONSTRAINT PK_Profesores PRIMARY             KEY (ID),
    -- Unique: Es nuestro ID PUBLICO
    CONSTRAINT UQ_Profesores_DNI                 UNIQUE (DNI)
    -- Restricciones al DNI aplicadas mediante un TRIGGER
);


-- Cómo es un DNI? 1-8 dígitos + letra mayúscula. Puntos y guiones opcionales
-- Para guardarlo podría usar un VARCHAR2(9). Cuánto ocuparía? 1byte por carácter = 9 bytes
-- Y si guardo el número como NUMBER(8) y la letra como CHAR(1)?  Número: 1 byte por cada 2 dígitos + 1 byte para la letra = 5 bytes
-- Cuantas personas tengo? 10.000.. Me la pela. 10.000.000... me lo planteo!

-- Meteremos un trigger a esa tabla para?
-- - Validar que lo que llega es correcto (formato + letra correcta)
-- - Normalizarlo (quitar puntos y guiones, poner letra en mayúsculas)


CREATE OR REPLACE PROCEDURE validar_dni (
    dni IN VARCHAR2,
    valido OUT BOOLEAN,
    numero OUT NUMBER,
    letra OUT CHAR
)
IS
    -- Declaración de variables locales
    letras_validas      CONSTANT    VARCHAR2(23) := 'TRWAGMYFPDXBNJZSQVHLCKE';
    patron_dni          CONSTANT    VARCHAR2(100) := '^(([0-9]{1,8})|([0-9]{1,2}([.][0-9]{3}){2})|([0-9]{1,3}[.][0-9]{3}))[ -]?[A-Za-z]$';
    patron_no_numerico  CONSTANT    VARCHAR2(100) := '[^0-9]';
    letra_correcta                  CHAR(1);
BEGIN
    valido := FALSE; -- Valor por defecto
    -- Cuerpo de la función
    IF dni IS NULL THEN
        RETURN ;
    END IF;
    -- Validar si tiene pinta de DNI (Expresión regular)
    -- Si no tiene pinta, devolver FALSE
    IF NOT REGEXP_LIKE(dni, patron_dni) THEN
        RETURN ;
    END IF;
    -- Si si tiene pinta de dni: Debo verificar la letra
    -- Extraer el número, quitando puntos y guiones, espacios y cogiendo solo los dígitos
    -- Reemplazamos todo lo que haya en el texto que no sean dígitos por nada
    numero := TO_NUMBER(REGEXP_REPLACE(dni, patron_no_numerico, '')); -- Todo lo que no sean números me lo como!
    -- Extraer la letra (último carácter)
    letra := UPPER(SUBSTR(dni, -1, 1)); -- Tomo un caracter(1) desde el último (-1)... y además transformo a mayúsculas
    -- Calcular la letra correcta que debería traer ese dni, en base al número
    letra_correcta := SUBSTR(letras_validas, MOD(numero, 23) + 1, 1); -- +1 porque los índices en SUBSTR empiezan en 1
    -- Verificar que es la que se ha suminitrado
    valido := (letra = letra_correcta);
END;
/

CREATE OR REPLACE TRIGGER TRG_Profesores_DNI_Validar_Normalizar
BEFORE INSERT OR UPDATE ON Profesores
FOR EACH ROW
DECLARE
    dni_valido      BOOLEAN;
    dni_numero      NUMBER(8);
    dni_letra       CHAR(1);
BEGIN
    -- Si el DNI Es null, no hacemos nada, y que el propio NOT NULL de la tabla se encargue de rechazarlo
    IF :NEW.DNI IS NULL THEN
        RETURN;
    END IF;
    -- Validar el formato del DNI
    validar_dni(:NEW.DNI, dni_valido, dni_numero, dni_letra);
    IF NOT dni_valido THEN
        RAISE_APPLICATION_ERROR(-20001, 'DNI inválido: ' || :NEW.DNI); -- Este mensaje le saldrá al usuario si el DNI no es válido
    ELSE
        -- Si es válido, normalizar el valor del DNI
        :NEW.DNI := TO_CHAR(dni_numero) || dni_letra; -- Número sin ceros a la izquierda + letra en mayúsculas, sin puntos ni separadores
    END IF;
END;
/

-- Esto estaría acabado! al menos lo referente a la tabla profesores.ALTER
-- Pero... ya que tengo ese procedimiento, me podría interesar generar un par de funciones adicionales, que los usuarios puedan usar en sus queries SQL.

-- funcion: es_dni_valido(dni IN VARCHAR2) RETURN NUMBER 
-- OJO. En SQL no puedo usar una función que devuelva BOOLEAN.
-- Como se comporta ante un nulo? Devuelva 0;
-- En SQL los booleanos no existen. Así que devuelvo un NUMBER: 1 = TRUE, 0 = FALSE

CREATE OR REPLACE FUNCTION es_dni_valido (
    dni IN VARCHAR2
) RETURN NUMBER
IS
    dni_valido      BOOLEAN;
    dni_numero      NUMBER(8);
    dni_letra       CHAR(1);
BEGIN
    validar_dni(dni, dni_valido, dni_numero, dni_letra);
    IF dni_valido THEN
        RETURN 1;
    ELSE
        RETURN 0;
    END IF;
END;
/

-- funcion: normalizar_dni(dni IN VARCHAR2) RETURN VARCHAR2
-- Si el dni no es válido, devuelve NULL
-- Si el DNI es null devuelve NULL
-- Esa funcion debe aceptar más argumentos:
-- - dni IN VARCHAR2
-- - si quiero rellenar con ceros                  -> Podeis echar un ojo a la función LPAD (no es obligatorio)
-- - si quiero separar con guiones o espacios o nada
-- - si quiero la letra en mayúsculas (UPPER) o minúsculas (LOWER)
-- - si quiero puntos en el número o no --- Esta en version 1 no!


CREATE OR REPLACE FUNCTION normalizar_dni (
    dni IN VARCHAR2,
    rellenar_con_ceros IN NUMBER DEFAULT 1,
    separador IN VARCHAR2 DEFAULT '',
    letra_mayuscula IN NUMBER DEFAULT 1,
    puntos_en_numero IN NUMBER DEFAULT 0
) RETURN VARCHAR2
IS
    dni_valido          BOOLEAN;
    dni_numero          NUMBER(8);
    dni_letra           CHAR(1);
    letra_normalizada   CHAR(1);
    numero_normalizado  VARCHAR2(10);
BEGIN
    validar_dni(dni, dni_valido, dni_numero, dni_letra);
    IF NOT dni_valido THEN
        RETURN NULL;
    END IF;
    -- Aquí realmente es donde normalizo el valor del DNI

    -- Normalización del número:
    numero_normalizado := TO_CHAR(dni_numero);
    -- Aplicar relleno con ceros a la izquierda si se ha pedido
    IF rellenar_con_ceros = 1 THEN
        -- Opción 1                      0000000123
        -- Siempre le pongo delante 7 ceros y luego corto los que sobren
        -- numero_normalizado := SUBSTR('0000000' || numero_normalizado, -8, 8); -- Coge 8 (8), desde los 8 últimos (-8)
        -- Opción 2
        numero_normalizado := LPAD(numero_normalizado, 8, '0'); -- Rellenar por la izquierda hasta tener 8 caracteres con ceros
                                                                -- Otra función a conocer, similar es RPAD (rellena por la derecha)
    END IF;
    -- Aplicar los separadores de miles y millones


    -- Normalización de la letra:

    -- OPCION 1, que ya conocíamos!
    -- IF letra_mayuscula = 1 THEN                   -- trabaja a nivel de statement: Es decir, lo que pongo dentro de las condiciones
    --                                           -- es un statement. Por ejemplo, en este caso hago una asignación
    --    letra_normalizada := UPPER(dni_letra);
    -- ELSE
    --    letra_normalizada := LOWER(dni_letra);
    -- END IF;
    -- OPCION 2: CASE:
    letra_normalizada := CASE                    -- trabaja a nivel de expresión: Lo que pongo dentro del CASE es una expresión
                                                 -- lo que asignamos en nuestro caso es el resultado de la expresión (CASE)
                             WHEN letra_mayuscula = 1 THEN UPPER(dni_letra)
                             ELSE LOWER(dni_letra)
                         END;


    -- empaqueto todo para devolverlo
    RETURN numero_normalizado || separador || letra_normalizada;
END;
/
-- SELECT nombre, apellidos, normalizar_dni(dni) AS dni_normalizado 
-- FROM Personas_A_Cargar 
-- WHERE es_dni_valido(dni) = 1;




-- Patrón de un dni? regex101 (Web para verificar expresiones regulares)
-- ^(([0-9]{1,8})|([0-9]{1,2}([.][0-9]{3}){2})|([0-9]{1,3}[.][0-9]{3}))[ -]?[A-Za-z]$
-- [0-9]{1,8} -- 23000000
-- [0-9]{1,2}([.][0-9]{3}){2} -- 23.000.000     2.300.000
-- [0-9]{1,3}[.][0-9]{3}-- 23.000T
-- Al crear un patrón de regex:
-- - Un patron es una secuencia de subpatrones
-- - Cada subpatrón es:
--   - Una secuencia de caracteres
--       - hola           En el texto debe aparecer 'hola'
--       - [hola]         En el texto debe aparecer cualquier letra de las que hay entre corchetes
--       - [a-zA-Z]       En el texto debe aparecer cualquier letra mayúscula o minúscula
--       - [0-9]          En el texto debe aparecer cualquier dígito
--       - [^hola]        En el texto NO debe aparecer ninguna letra de las que hay entre corchetes
--       - .              En el texto puede aparecer cualquier carácter
--   - Seguido de un modificador de cantidad
--       - No poner nada  Aparece exactamente 1 vez
--       - ?              Aparece 0 o 1 veces
--       - +              Aparece 1 o más veces
--       - *              Aparece 0 o más veces
--       - {n}            Aparece exactamente n veces
--       - {n,}           Aparece n o más veces
--       - {n,m}          Aparece entre n y m veces
-- Otros operadores:
--   - ^              Indica el inicio del texto
--   - $              Indica el final del texto
--   - ()             Agrupa subpatrones
--   - |              Operador OR entre subpatrones