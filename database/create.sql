
-- 
-- Tabla: Tipos de Cursos
--

CREATE TABLE Tipos_Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL,
    DESCRIPCION                 VARCHAR2(4000),

 -- CONSTRAINS
    CONSTRAINT PK_Tipos_Cursos PRIMARY KEY (ID),
    CONSTRAINT UQ_Tipos_Cursos_Codigo UNIQUE (CODIGO)
);

-- 
-- Tabla: Cursos
--

CREATE TABLE Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL,
    DURACION                    NUMBER,
    TIPO                        NUMBER,
    PRECIO_PARA_EMPRESAS        NUMBER,
    PRECIO_PARA_PARTICULARES    NUMBER,
    DESCRIPCION                 VARCHAR2(4000),

 -- CONSTRAINS
    -- Primary Key. Siempre tenemos uno
    CONSTRAINT PK_Cursos PRIMARY                KEY (ID),
    -- Unique: Es nuestro ID PUBLICO
    CONSTRAINT UQ_Cursos_Codigo                 UNIQUE (CODIGO),
                                                -- Este campo, por tener ser una clave única en automático tiene un índice asociado
                                                -- Búsquedas del tipo WHERE CODIGO = 'valor' serán muy rápidas
                                                -- Búsquedas del tipo WHERE CODIGO LIKE 'valor%' serán muy rápidas
    -- Foreign Key hacia Tipos_Cursos
    CONSTRAINT FK_Cursos_Tipo FOREIGN           KEY (TIPO) REFERENCES Tipos_Cursos(ID),
    -- Restricciones al valor de los campos
                                                -- AQUI PONEMOS UNA EXPRESION QUE DEVUELVA UN BOOLEANO
                                                -- Si devuelve TRUE, se acepta el valor
                                                -- Si devuelve FALSE, se rechaza el valor
    CONSTRAINT CHK_Cursos_Duracion              CHECK (DURACION IS NULL OR DURACION > 0),
    CONSTRAINT CHK_Cursos_Precio_Empresas       CHECK (PRECIO_PARA_EMPRESAS IS NULL OR PRECIO_PARA_EMPRESAS >= 0),
    CONSTRAINT CHK_Cursos_Precio_Particulares   CHECK (PRECIO_PARA_PARTICULARES IS NULL OR PRECIO_PARA_PARTICULARES >= 0)
    CONSTRAINT CHK_Cursos_Codigo_Mayusculas     CHECK (CODIGO = UPPER(CODIGO) AND REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
);


-- Notas respecto al campo CODIGO:
-- - Será muy recomendable implementar un AUTOCOMPLETAR en los formularios de búsqueda: ORA-     ora-      Ora-
-- - Podría ser que el usuario escriba minúsculas o mayúsculas de forma indistinta al buscar <- Quiero dar esa opción?
-- - Lo que nos estamos preguntando es: Quiero que el valor de ese campo sea case-sensitive o case-insensitive?
-- - Y en un campo como este, lo guay es que sea case-insensitive
-- - Esa funcionalidad la podríamos implementar en una query : WHERE UPPER(CODIGO) = UPPER('valor_del_usuario')
--                                                             WHERE UPPER(CODIGO) LIKE UPPER('valor_del_usuario') || '%'
--                                                             WHERE UPPER(CODIGO) LIKE '%' || UPPER('valor_del_usuario') || '%'
-- Pregunta?  Me funciona el índice que he creado en esos casos?
-- Respuesta: NO, ya que lo que tengo indexado es el valor del CODIGO... y en la query se usa el UPPER(CODIGO).
--            Y ese valor no está indexado!
-- Esto implica que hay que transformar bajo demanda, en cada query, todos los valores del campo CODIGO a mayúsculas
-- para poder comparar con el valor que ha dado el usuario. EL INDICE SE VUELVE INUTIL!
-- Opciones:
-- 1. Transformar en automático el valor del campo CODIGO a mayúsculas en el momento de hacer el INSERT o el UPDATE
--    Eso lo permite SQL? NO
--    Con un trigger y PL/SQL SÍ
-- 2. Forzar que el campo solo pueda recibir valores en mayúsculas. Limitación al rango de valores aceptables
--    Eso lo permite SQL? SÍ, con un CONSTRAINT CHECK
-- 3. Generar un índice adicional basado en la función UPPER(CODIGO). Índice funcional
--    Eso lo permite SQL? SÍ
--    CREATE INDEX IX_Cursos_Codigo_Upper ON Cursos(UPPER(CODIGO));
--    En este caso, tendríamos 2 índices. Más espacio y más tiempo en los INSERTs/UPDATEs.
--    Y Además, lo que me gustaría es de alguna forma NORMALIZAR el valor del campo CODIGO a mayúsculas.
--    Esto no exige que el campo se almacene en mayúsculas, pero sí que el valor indexado lo esté.
--    En otros escenarios, esto podría ser una solución interesante. En este NO.

-- Entre opción 1 y opción 2, nos quedamos con las 2.
-- La opción 2, es la que asegura que el valor del campo CODIGO siempre estará en mayúsculas.
-- La opción 1, es la que nos permite dar al usuario la flexibilidad de escribir minúsculas o mayúsculas al dar de alta el campo.

-- Implementando eso (o incluso si implementamos la opción 3), las búsquedas que usarán índice serían:
-- WHERE CODIGO = UPPER('VALOR_EN_MAYUSCULAS')
-- WHERE CODIGO LIKE UPPER('VALOR_EN_MAYUSCULAS') || '%'
-- ESTA NO FUNCIONA : WHERE CODIGO LIKE '%' || UPPER('VALOR_EN_MAYUSCULAS') 
--                    La búsqueda sin funcionaría, pero no usaría índice
-- El % al principio en los LIKES impide usar índice. Estas queries deberían estar proscritas en un entorno con grandes volúmenes de datos.
-- A no ser que tenga 200 datos en la tabla, claro.
-- Si quiero búsquedas de ese estilo, o búsquedas que no discrimen por acentos, o que automáticamente ignoren mayúsculas/minúsculas, la solución es otra:
-- - Índices invertidos full text: Oracle Text (eso viene con la propia licencia de Oracle Database), aunque he de activarlo explícitamente y configurarlo


-- Trigger para asegurar que el campo CODIGO siempre se almacena en mayúsculas
CREATE OR REPLACE TRIGGER TRG_Cursos_Codigo_Mayusculas
BEFORE INSERT OR UPDATE ON Cursos
FOR EACH ROW
BEGIN
    -- Solo transformamos el valor si no es NULL
    -- De esta forma evitamos que el trigger falle al intentar transformar un NULL
    -- Si es nulo, lo dejamos como está, es decir NULL
    -- Y ya la restricción NOT NULL definida en la tabla se encargará de rechazarlo si es necesario dando un mensaje adecuado al usuario

    -- En el caso de un UPDATE, si el valor no cambia, el valor :NEW.CODIGO se queda como está, no lo tocamos... y sigue funcionando bien.
    IF :NEW.CODIGO IS NOT NULL THEN 
        :NEW.CODIGO := UPPER(:NEW.CODIGO);
    END IF;
END;
/
-- Nota: El trigger se define con una barra (/) al final para indicar a SQL*Plus que ejecute el bloque PL/SQL.